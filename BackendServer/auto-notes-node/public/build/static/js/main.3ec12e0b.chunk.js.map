{"version":3,"sources":["components/Whiteboard.js","components/WhiteboardTools.js","components/InformationSpace.js","App.js","index.js"],"names":["sketch","s","model","mathFont","catergories","backgroundColor","color","tools","pen","keyCode","name","down","mouseX","panVector","x","width","mouseY","y","height","latestLine","path","border","text","timeFinished","shouldAutoMatch","allLines","push","drag","point","createVector","release","borderInfo","getBorder","Date","now","allowAutoMatch","eraser","fill","ellipse","forEach","line","topLeft","bottomRight","splice","indexOf","allSymbols","symbol","pan","mouseOffset","currentTool","networkInputSize","allowNewMatch","matchWithSymbol","paths","a","probabilityOfSymbols","feature","tf","getStrokeArray","prediction","predict","arraySync","max","reduce","b","Math","probValue","label","length","reverse","smbl","symbolBorder","textToUse","abs","maxWidth","bounds","textBounds","newSize","w","h","newBounds","textLocation","txtLoc","textSize","LinesToRemove","console","log","getPossiblePaths","mainLine","nearbyPaths","possiblePaths","latestTime","centerOffset","scale","resizedArray","Array","resizedLines","loc","round","i","repeatTimes","ceil","sqrt","j","indexToChange","sign","gradient","direction","xCoord","map","setup","loadFont","textFont","loadModel","penButton","document","getElementById","eraserButton","panButton","matchCheckbox","addEventListener","checked","addButtonEventListeners","toolBarDiv","createCanvas","window","innerWidth","offsetWidth","innerHeight","background","draw","translate","stroke","strokeWeight","concat","toString","mouseIsPressed","featuresToCheck","noFill","beginShape","vertex","endShape","mousePressed","mouseReleased","keyTyped","tool","pop","Whiteboard","board","React","createRef","this","myP5","p5","current","id","ref","Component","WhiteboardTools","type","onClick","props","swapBoard","InformationSpace","href","App","state","showingBoard","swapBoards","bind","button","innerHTML","setState","preState","ReactDOM","render"],"mappings":"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","file":"static/js/main.3ec12e0b.chunk.js","sourcesContent":["import React from \"react\";\r\nimport p5 from \"p5\";\r\nimport * as tf from '@tensorflow/tfjs';\r\n\r\n\r\n\r\n\r\n//This is the processing sketch, used in instance mode\r\nconst sketch = ( s ) => \r\n{        \r\n    const catergories = \r\n    ['!','(',')','+','|','―','0','1','2','3','4','5','6','7','8','9','=','𝑎','α','|',\r\n    '𝑏','β','𝑐','cos','𝑑','Δ','÷','𝑒','∃','𝑓','∀','𝑔','γ','≥','>','𝒉','𝑖','in','∞',\r\n    '∫','𝑗','𝑘','ℓ','λ','≤','lim','log','<','𝑚','mu','𝑛','≠','𝑜','𝑝','ϕ','π','±','𝑞','𝑟','→',\r\n    '𝑠','σ','sin','√','Σ','𝑡','tan','θ','×','𝑢','𝑣','𝑤','𝑥','𝑦','𝑧','[',']','{','}']\r\n        let model;        \r\n        let mathFont;\r\n        const backgroundColor = s.color(230, 230, 241);\r\n        const tools = {\r\n            pen : {\r\n                //X\r\n                keyCode : 80,\r\n                name : \"pen\",\r\n                down : () => {\r\n                    if (s.mouseX - panVector.x >= 0 && s.mouseX - panVector.x <= s.width && s.mouseY - panVector.y >= 0 && s.mouseY - panVector.y <= s.height)\r\n                    {\r\n                        latestLine = {\r\n                            path : [],\r\n                            border : null,\r\n                            text : null,\r\n                            timeFinished : null,\r\n                            shouldAutoMatch : false\r\n                        };\r\n                        allLines.push(latestLine);\r\n                    }\r\n                },\r\n                drag : () => {                    \r\n                    let point = s.createVector(s.mouseX - panVector.x, s.mouseY - panVector.y)\r\n                    latestLine.path.push(point);\r\n                },\r\n                release : () => {\r\n                    let borderInfo = getBorder([latestLine.path]);\r\n                    latestLine.timeFinished = Date.now();            \r\n                    latestLine.border = borderInfo; \r\n                    latestLine.shouldAutoMatch = allowAutoMatch;\r\n                }\r\n            },\r\n            eraser : {\r\n                //S\r\n                keyCode : 69,\r\n                name : \"eraser\",\r\n                down : () => {\r\n                    \r\n                },\r\n                drag : () => {\r\n                    s.fill(255, 100, 100);\r\n                    s.ellipse(s.mouseX - panVector.x, s.mouseY - panVector.y, 10, 10);\r\n                    allLines.forEach(line => {\r\n                        if (s.mouseX - panVector.x > line.border.topLeft.x && s.mouseX - panVector.x < line.border.bottomRight.x)\r\n                        {\r\n                            if (s.mouseY - panVector.y > line.border.topLeft.y && s.mouseY - panVector.y < line.border.bottomRight.y)\r\n                            {\r\n                                allLines.splice(allLines.indexOf(line), 1);\r\n                            }                        \r\n                        }\r\n                    });\r\n                    allSymbols.forEach(symbol => {\r\n                        if (s.mouseX - panVector.x > symbol.border.topLeft.x && s.mouseX - panVector.x < symbol.border.bottomRight.x)\r\n                        {\r\n                            if (s.mouseY - panVector.y > symbol.border.topLeft.y && s.mouseY - panVector.y < symbol.border.bottomRight.y)\r\n                            {\r\n                                allSymbols.splice(allSymbols.indexOf(symbol), 1);\r\n                            }                        \r\n                        }\r\n                    });\r\n                },\r\n                release : () => {\r\n                    \r\n                }\r\n            },\r\n            pan : {\r\n                //a\r\n                keyCode : 65,\r\n                name : \"pan\",\r\n                down : () => {\r\n                    mouseOffset = s.createVector(s.mouseX - panVector.x, s.mouseY - panVector.y);\r\n                },\r\n                drag : () => {\r\n                    panVector = s.createVector(s.mouseX - mouseOffset.x, s.mouseY- mouseOffset.y);\r\n                },\r\n                release : () => {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        let currentTool = tools.pen;\r\n        let panVector = s.createVector(0, 0);\r\n        \r\n        const networkInputSize = 45;\r\n        //only allows a match once the previous one has been completely converted\r\n        let allowNewMatch = true;\r\n        let allowAutoMatch = true;\r\n        const minimumMatchPercent = 0.6;\r\n        const confidenceThreshold = 0.05;\r\n        \r\n        const considerDeltaTime = 700;\r\n        const changeThresholdTime = 1000;\r\n        \r\n        const snapLocationMargin = 20;\r\n        const snapSizeMargin = 50;\r\n        \r\n        let mouseOffset = s.createVector(0, 0);\r\n        \r\n        let allLines = [];\r\n        let allSymbols = [];\r\n        let latestLine = {\r\n            path : [],\r\n            border : null,\r\n            text : null,\r\n            timeFinished : null,\r\n            shouldAutoMatch : false\r\n        };\r\n        \r\n        s.setup = () => {\r\n            mathFont = s.loadFont(\"/api/getFont\");\r\n            s.textFont(mathFont);\r\n            loadModel();\r\n            addButtonEventListeners();\r\n            const toolBarDiv = document.getElementById('sidebar');\r\n            s.createCanvas(window.innerWidth-toolBarDiv.offsetWidth-20, window.innerHeight-50);\r\n            s.background(backgroundColor);\r\n        };\r\n        \r\n        s.draw = () => {\r\n            //clear the background\r\n            s.background(backgroundColor);\r\n            s.translate(panVector.x, panVector.y);\r\n            //show on screen the current window location\r\n            s.textSize(20);\r\n            s.stroke(0);\r\n            s.strokeWeight(1);\r\n            s.fill(0);\r\n            s.text(''.concat(\"x:\", panVector.x.toString(), \", y:\", panVector.y.toString()), -panVector.x, -panVector.y+20);\r\n            s.textSize(30);\r\n            s.text(currentTool.name, -panVector.x, s.height-panVector.y);\r\n\r\n            if (s.mouseIsPressed)\r\n            {\r\n                currentTool.drag();\r\n            }\r\n            \r\n            //redraw all the lines\r\n            allLines.forEach(line => {\r\n                //auto match \r\n                if (allowNewMatch && line.shouldAutoMatch && Math.abs(line.timeFinished-Date.now()) >= changeThresholdTime)\r\n                {\r\n                    allowNewMatch = false;\r\n                    let nearbyPaths = getPossiblePaths(line);                \r\n                    let featuresToCheck = []\r\n                    nearbyPaths.forEach(path => {\r\n                        featuresToCheck.push(path);\r\n                    });\r\n                    matchWithSymbol(featuresToCheck);\r\n                }\r\n                //redraw all the lines\r\n                if (line.text == null)\r\n                {\r\n                    s.noFill();\r\n                    s.strokeWeight(7);\r\n                    s.beginShape();\r\n                    line.path.forEach(point => {\r\n                        s.vertex(point.x, point.y);\r\n                    });\r\n                    s.endShape();\r\n                }\r\n            });\r\n\r\n            //redraw all the text\r\n            allSymbols.forEach(symbol => {\r\n                s.textSize(symbol.textSize);   \r\n                s.fill(0, 0, 0);\r\n                s.strokeWeight(1);\r\n                s.stroke(0);\r\n                s.text(symbol.text, symbol.txtLoc.x, symbol.txtLoc.y);                \r\n            });\r\n\r\n        };\r\n\r\n        s.mousePressed = () => \r\n        {     \r\n            currentTool.down();\r\n        }\r\n\r\n        s.mouseReleased = () =>\r\n        {\r\n            currentTool.release();      \r\n        }\r\n\r\n        s.keyTyped = () =>\r\n        {\r\n            for (var tool in tools)\r\n            {\r\n                if (s.keyCode === tools[tool].keyCode)\r\n                {\r\n                    currentTool.release();\r\n                    currentTool = tools[tool];\r\n                }\r\n            }\r\n\r\n            //convert Last Written number into text: press letter C\r\n            if (s.keyCode === 67 && latestLine.timeFinished != null)\r\n            {\r\n                let nearbyPaths = getPossiblePaths(latestLine);               \r\n                let featuresToCheck = []\r\n                nearbyPaths.forEach(path => {\r\n                    featuresToCheck.push(path);\r\n                });\r\n                matchWithSymbol(featuresToCheck);\r\n            }\r\n            //clear onscreen things: press letter R\r\n            else if (s.keyCode === 82)\r\n            {\r\n                allLines = [];\r\n                allSymbols = [];\r\n            }\r\n            //z\r\n            else if (s.keyCode === 90 && allSymbols.length !== 0)\r\n            {\r\n                allSymbols[allSymbols.length-1].paths.forEach(path => {\r\n                    latestLine = {\r\n                        path : path,\r\n                        border : getBorder([path]),\r\n                        text : null,\r\n                        timeFinished : Date.now(),\r\n                        shouldAutoMatch : false\r\n                    };\r\n                    allLines.push(latestLine);\r\n                });                                \r\n                allSymbols.pop();\r\n            }\r\n        }\r\n\r\n        //takes in an array of features, paths, and will check through all and converts the most likely \r\n        async function matchWithSymbol(paths)\r\n        {\r\n            let probabilityOfSymbols = []\r\n            await paths.forEach(path => {\r\n                let feature = tf.tensor(getStrokeArray(path), [1, 45, 45, 1]);\r\n                let prediction = model.predict([feature]).arraySync()[0];\r\n                let max = prediction.reduce((a, b) => {\r\n                    return Math.max(a, b);\r\n                });\r\n                probabilityOfSymbols.push({\r\n                    probValue : max,\r\n                    label : catergories[prediction.indexOf(max)],\r\n                    paths : path\r\n                });\r\n            });\r\n            let symbol = probabilityOfSymbols[probabilityOfSymbols.length-1];\r\n            probabilityOfSymbols.reverse().forEach(smbl => {\r\n                if (smbl.probValue - symbol.probValue >= confidenceThreshold)\r\n                {\r\n                    symbol = smbl;\r\n                }\r\n            }); \r\n            //we dont convert if the model is not confident in its guess \r\n            if (symbol.probValue < minimumMatchPercent)\r\n            {\r\n                allLines.forEach(line => {\r\n                    symbol.paths.forEach(path => {\r\n                        if (line.path === path)\r\n                        {\r\n                            line.shouldAutoMatch = false;\r\n                        }\r\n                    });\r\n                });\r\n                allowNewMatch = true;\r\n                return;\r\n            }\r\n            //calculate the new Size, drawn text location\r\n            let symbolBorder = getBorder(symbol.paths);\r\n            let textToUse = symbol.label;\r\n\r\n            //why does p5js have this bug\r\n            //trying to get bounds of the closing bracket will return infinity, so i have to try and replace it with a similar text as otherwise the drawing \r\n            //system will break\r\n            if (textToUse ===\")\")\r\n            {\r\n                textToUse = \"(\";\r\n            }\r\n            \r\n            //allow for symbol to snap to nearby texts\r\n            allSymbols.forEach(smbl => {\r\n                if (Math.abs(smbl.border.maxWidth-symbolBorder.maxWidth) <= snapSizeMargin)\r\n                {\r\n                    if (Math.abs(smbl.border.bottomRight.y-symbolBorder.bottomRight.y) <= snapLocationMargin)\r\n                    {\r\n                        if (Math.abs(smbl.border.topLeft.x-symbolBorder.topLeft.x) <= smbl.border.maxWidth*1.5)\r\n                        {\r\n                            symbolBorder.maxWidth = smbl.border.maxWidth;                            \r\n                            symbolBorder.topLeft.y = smbl.border.topLeft.y;\r\n                            symbolBorder.bottomRight.y = smbl.border.bottomRight.y;\r\n                        }\r\n                    }\r\n                }\r\n            });     \r\n            \r\n            let bounds = mathFont.textBounds(textToUse, symbolBorder.topLeft.x, symbolBorder.bottomRight.y, symbolBorder.maxWidth);\r\n            let newSize = bounds.w > bounds.h ? symbolBorder.maxWidth * (symbolBorder.maxWidth/bounds.w) : symbolBorder.maxWidth * (symbolBorder.maxWidth/bounds.h);            \r\n            let newBounds = mathFont.textBounds(textToUse, symbolBorder.topLeft.x, symbolBorder.bottomRight.y, newSize);\r\n            let textLocation = s.createVector(symbolBorder.topLeft.x + (symbolBorder.maxWidth/2+symbolBorder.topLeft.x) - (newBounds.w/2+newBounds.x),\r\n            symbolBorder.bottomRight.y - (newBounds.h/2+newBounds.y) +  (symbolBorder.topLeft.y+symbolBorder.maxWidth/2));\r\n            allSymbols.push({\r\n                text : symbol.label,\r\n                border : symbolBorder,\r\n                txtLoc : textLocation,\r\n                textSize : newSize,\r\n                paths : symbol.paths\r\n            });\r\n\r\n            //remove the lines that got converted\r\n            let LinesToRemove = []\r\n            allLines.forEach(line => {\r\n                symbol.paths.forEach(path => {\r\n                    if (line.path === path)\r\n                    {\r\n                        LinesToRemove.push(line);\r\n                    }\r\n                });\r\n            });\r\n            LinesToRemove.forEach(line => {\r\n                allLines.splice(allLines.indexOf(line), 1);\r\n            });\r\n            allowNewMatch = true;\r\n        }\r\n\r\n        async function loadModel()\r\n        {\r\n            console.log(\"loading model\");\r\n            model = await tf.loadLayersModel(\"/api/getModel\");\r\n            console.log(\"loaded model\");\r\n        }\r\n\r\n        function addButtonEventListeners()\r\n        {\r\n            const penButton = document.getElementById(\"penButton\");\r\n            const eraserButton = document.getElementById(\"eraserButton\");\r\n            const panButton = document.getElementById(\"panButton\");\r\n            const matchCheckbox = document.getElementById(\"matchCheckbox\");\r\n\r\n            penButton.addEventListener('click', ()=>{\r\n                currentTool = tools[\"pen\"];\r\n            });\r\n            eraserButton.addEventListener('click', ()=>{\r\n                currentTool = tools[\"eraser\"];\r\n            });\r\n            panButton.addEventListener('click', ()=>{\r\n                currentTool = tools[\"pan\"];\r\n            });\r\n            matchCheckbox.checked = allowAutoMatch;\r\n            matchCheckbox.addEventListener(\"change\", ()=> {\r\n                allowAutoMatch = matchCheckbox.checked;\r\n            });\r\n        }\r\n\r\n        //takes in a line, and returns all paths nearby, or that were drawn close in time\r\n        function getPossiblePaths(mainLine)\r\n        {\r\n            let borderInfo = getBorder([mainLine.path]);\r\n            let nearbyPaths = [mainLine.path]\r\n            let possiblePaths = [];\r\n            let latestTime = mainLine.timeFinished;\r\n            possiblePaths.push([...nearbyPaths]);\r\n            allLines.forEach(line => {\r\n                if (line !== mainLine && line.timeFinished != null)\r\n                {                                   \r\n                    //look for any nearby lines\r\n                    if (line.border.topLeft.x + line.border.maxWidth > borderInfo.topLeft.x && line.border.topLeft.x < borderInfo.topLeft.x + borderInfo.maxWidth &&\r\n                        line.border.topLeft.y + line.border.maxWidth > borderInfo.topLeft.y && line.border.topLeft.y < borderInfo.topLeft.y + borderInfo.maxWidth)\r\n                    { \r\n                        nearbyPaths.push(line.path);\r\n                        possiblePaths.push([...nearbyPaths]);\r\n                        borderInfo = getBorder(nearbyPaths);\r\n                        latestTime = line.timeFinished;\r\n                    }\r\n                    //look for lines that were drawn within considerDeltaTime of the main line\r\n                    else if (Math.abs(latestTime-line.timeFinished) <= considerDeltaTime)                \r\n                    {\r\n                        nearbyPaths.push(line.path);\r\n                        possiblePaths.push([...nearbyPaths]);\r\n                        borderInfo = getBorder(nearbyPaths);\r\n                        latestTime = line.timeFinished;\r\n                    }\r\n                }\r\n            });\r\n            return possiblePaths;\r\n        }\r\n\r\n        //takes in an array of path, and returns the border information that surrounds the path\r\n        function getBorder(paths)\r\n        {\r\n            let topLeft = s.createVector(s.width,s.height)\r\n            let bottomRight = s.createVector(0,0)\r\n            paths.forEach(path => {\r\n                path.forEach(point => {\r\n                    if (point.x < topLeft.x)\r\n                    {\r\n                        topLeft.x = point.x\r\n                    }\r\n                    if (point.y < topLeft.y)\r\n                    {\r\n                        topLeft.y = point.y\r\n                    }\r\n                    if (point.x > bottomRight.x)\r\n                    {\r\n                        bottomRight.x = point.x\r\n                    }\r\n                    if (point.y > bottomRight.y)\r\n                    {\r\n                        bottomRight.y = point.y\r\n                    }\r\n                });\r\n            });\r\n            let maxWidth = bottomRight.x-topLeft.x > bottomRight.y-topLeft.y ? bottomRight.x-topLeft.x : bottomRight.y-topLeft.y;  \r\n            let centerOffset = s.createVector((maxWidth - (bottomRight.x-topLeft.x)) /2, (maxWidth - (bottomRight.y-topLeft.y))/2 );\r\n            return {\r\n                maxWidth : maxWidth,\r\n                topLeft : s.createVector(topLeft.x-centerOffset.x, topLeft.y-centerOffset.y),\r\n                bottomRight : s.createVector(bottomRight.x-centerOffset.x, bottomRight.y+centerOffset.y)\r\n            };\r\n        }\r\n\r\n        //takes in the array of path, and the border surrounding it, and returns an array of 1 and 0 to parse into model\r\n        function getStrokeArray(paths, border = getBorder(paths))\r\n        {               \r\n            //remap all the points onto the resized array, of which the dimensions are networkInputSize\r\n            let scale = (networkInputSize-1)/border.maxWidth;\r\n            let resizedArray = new Array(networkInputSize**2).fill(0);            \r\n            paths.forEach(path => {                \r\n                let resizedLines = []\r\n                path.forEach(point => {\r\n                    let loc = s.createVector(Math.round((point.x-border.topLeft.x)*scale ), Math.round((point.y-border.topLeft.y)*scale ));  \r\n                    resizedLines.push(loc);                \r\n                });         \r\n                //loop through all the points, and connect them together\r\n                for (let i = 0;i < resizedLines.length;i++)\r\n                {\r\n                    if (i !== path.length-1)\r\n                    {                    \r\n                        let repeatTimes = Math.ceil( Math.sqrt( (path[i].x-path[i+1].x)**2 + (path[i].y-path[i+1].y)**2 ) );\r\n    \r\n                        //if the line is vertical, a graident is not possible\r\n                        //therefore, we use a different function to fill in the points\r\n                        if (Math.abs(resizedLines[i].x-resizedLines[i+1].x) === 0)                    \r\n                        {\r\n                            for (let j = 0;j<Math.abs(resizedLines[i].y-resizedLines[i+1].y);j++)\r\n                            {\r\n                                let indexToChange = resizedLines[i].x + networkInputSize*(resizedLines[i].y - j*Math.sign(resizedLines[i].y-resizedLines[i+1].y));//\r\n                                resizedArray[indexToChange] = 1\r\n                            }\r\n                        }\r\n                        //calculate gradient, then fill in the line inbetween two points\r\n                        else\r\n                        {\r\n                            let gradient = (resizedLines[i].y-resizedLines[i+1].y)/(Math.abs(resizedLines[i].x-resizedLines[i+1].x));\r\n                            let direction = Math.sign(resizedLines[i].x-resizedLines[i+1].x);\r\n                            \r\n                            for (let j = 0;j < repeatTimes;j++)\r\n                            {   \r\n                                let xCoord = s.map(j, 0, repeatTimes, 0, Math.abs(resizedLines[i].x-resizedLines[i+1].x));\r\n                                let indexToChange = resizedLines[i].x-(direction*Math.round(xCoord)) + networkInputSize*Math.round((resizedLines[i].y-gradient*xCoord));\r\n                                resizedArray[indexToChange] = 1\r\n                            }\r\n                        }                    \r\n                    }\r\n                    resizedArray[Math.round(resizedLines[i].x + networkInputSize*resizedLines[i].y)] = 1\r\n                }\r\n            });\r\n            return resizedArray;\r\n        }\r\n    };\r\n\r\n\r\n\r\nclass Whiteboard extends React.Component\r\n{\r\n    constructor()\r\n    {\r\n        super();\r\n        this.board = React.createRef();\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.myP5 = new p5(sketch, this.board.current)\r\n    }\r\n\r\n    render()\r\n    {        \r\n        return (\r\n            <div id=\"whiteboard\" ref={this.board}></div>\r\n        );\r\n    }\r\n}\r\nexport default Whiteboard;","import React from \"react\";\r\n\r\nclass WhiteboardTools extends React.Component\r\n{\r\n    render()\r\n    {\r\n        return (<div id=\"sidebar\">\r\n            <ul>\r\n                <li>\r\n                    <label>Pen (p):</label><br/>\r\n                    <button id=\"penButton\">pen</button>                   \r\n                </li>\r\n                <li>\r\n                    <label>Eraser (e):</label><br/>\r\n                    <button id=\"eraserButton\">eraser</button>                   \r\n                </li>\r\n                <li>\r\n                    <label>pan (a):</label><br/>\r\n                    <button id=\"panButton\">pan</button>                   \r\n                </li>\r\n                <li>\r\n                    <label>Match:</label><br/>\r\n                    <input id=\"matchCheckbox\" type=\"checkbox\"></input>                   \r\n                </li>\r\n                <li>\r\n                    <button id=\"swapButton\" onClick={this.props.swapBoard}>About</button>               \r\n                </li>\r\n            </ul>\r\n        </div>);\r\n    }\r\n}\r\n\r\nexport default WhiteboardTools;","import React from \"react\";\r\n\r\nclass InformationSpace extends React.Component\r\n{\r\n    render()\r\n    {\r\n        return (<div id=\"infoSpace\">\r\n            <h1>\r\n                A quick Explaination\r\n            </h1>\r\n            <p>\r\n                This is a drawing programme that recognises mathematical symbols. \r\n                To use, draw out the symbol. The programme will then try to make its best guess\r\n                and replace the drawn symbol into the text version. Either wait for a few seconds \r\n                for the programme to change it, or press (c) to instantly convert the last drawn line into\r\n                the symbol. Pressing (z) will undo the latest conversion. The match checkbox will either enable to disable the guess.\r\n            </p>\r\n\r\n            <p>\r\n                The symbols the model will recognise are : <br/>\r\n                !, (, ), +, |, ―, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, =, 𝑎, α, |, <br/>\r\n                𝑏, β, 𝑐, cos, 𝑑, Δ, ÷, 𝑒, ∃, 𝑓, ∀, 𝑔, γ, ≥, {\">\"}, 𝒉, 𝑖, in, ∞, <br/>\r\n                ∫, 𝑗, 𝑘, ℓ, λ, ≤, lim, log, {\"<\"}, 𝑚, mu, 𝑛, ≠, 𝑜, 𝑝, ϕ, π, ±, 𝑞, 𝑟, →, <br/>\r\n                𝑠, σ, sin, √, Σ, 𝑡, tan, θ, ×, 𝑢, 𝑣, 𝑤, 𝑥, 𝑦, 𝑧, [, ], {\"{\"}, {\"}\"} <br/>\r\n            </p>\r\n\r\n            <p>\r\n                The dataset that was used can be found at <a href=\"https://www.kaggle.com/xainano/handwrittenmathsymbols\">Here</a>.\r\n                Also, some code were referenced from <a href=\"https://www.florin-pop.com/blog/2019/04/drawing-app-built-with-p5js/\">This blog</a>.                \r\n            </p>\r\n            <h2>\r\n                Quick Thoughts:\r\n            </h2>\r\n            <p>\r\n                The model is an CNN, that takes in the line drawn, and nearby lines/ lines that were drawn close in time, and makes a guess as to what was drawn. <br/>\r\n                A giant problem with my method of predicting is, that i literally have no idea when a character is drawn and when the next starts.\r\n                For example, one could try and draw an x, which takes 2 strokes, which could be intepreted as brackets.  x and )( look alike. There is also a problem with \r\n                symbols looking alike, like x(letter) and ×(times). <br/>\r\n                This makes predicting the symbol really hard to do. \r\n                Any suggestions or criticisms pls do tell :)\r\n                (msg me on reddit u/irony94)\r\n\r\n            </p>\r\n        </div>);\r\n    }\r\n}\r\n\r\nexport default InformationSpace;","import React from \"react\";\r\nimport Whiteboard from \"./components/Whiteboard\";\r\nimport WhiteboardTools from \"./components/WhiteboardTools\";\r\nimport InformationSpace from \"./components/InformationSpace\";\r\n\r\nclass App extends React.Component\r\n{\r\n    constructor()\r\n    {\r\n        super();\r\n        this.state = {\r\n            showingBoard : true\r\n        }\r\n        this.swapBoards = this.swapBoards.bind(this);\r\n    }\r\n\r\n    swapBoards()\r\n    {\r\n        let button = document.getElementById(\"swapButton\");\r\n        if (button.innerHTML === \"About\")\r\n        {\r\n            button.innerHTML = \"Board\";\r\n        }\r\n        else\r\n        {\r\n            button.innerHTML = \"About\";\r\n        }\r\n        this.setState(preState => {\r\n            return {\r\n                showingBoard : !preState.showingBoard\r\n            }\r\n        });\r\n    }\r\n\r\n    render()\r\n    {\r\n        return (\r\n            <div id=\"app\">\r\n                <div id=\"drawingApp\">    \r\n                    <WhiteboardTools swapBoard={this.swapBoards}/>                    \r\n                    {this.state.showingBoard ? <Whiteboard/> : <InformationSpace/>}\r\n                    \r\n                </div>\r\n                \r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\n    \r\nReactDOM.render(<App/>, document.getElementById(\"root\"));"],"sourceRoot":""}